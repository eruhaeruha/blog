노이만 머신
* 컴퓨터를 단순하게 정의, 반복적인 일을 빠르게 처리함으로써 원하는 목적을 달성하고자 함
* 메모리에 있는 명령, 값을 꺼내서 cpu에 올려서 연산 후 메모리에 넣는 것을 끊임없이 반복하는 것
* 오퍼랜드(1, 2)와 명령어(+)로 되어있음
* 레지스터라는 cpu안의 메모리에 오퍼랜드와 명령어를 옮겨서 연산 후에 나온 값(3)을 메모리에 옮김 -> 재활용
* 모든 명령을 소비하면 프로그램 종료
* 노이만 머신은 실행을 시작하면 쉬지 않고 명령을 소비함
* 노이만 머신이 모든 명령을 실행하고 종료되는 과정을 flow라고 함 -> 동기화(sync)
* flow에 관여하지 못하게 되어있음
* sync를 어길 수 있는 다양한 기법을 비동기성이라고 함
* 기계어는 명령을 다 실행하고 끝나지만 랭귀지 코드에서 기계어 코드와 매칭되는   형태로 언어를 짤지에 대한 기본 규칙이 lr파서 규칙임
    * sync flow는 좌 -> 우, 위 -> 아래로 감
    * a = 3; b = 2; 라고 되어있다면 좌 -> 우, 위 -> 아래로 해석, 실행될 것이라고 생각할 수 있는 것은 이러한 규칙 때문
    * 랭귀지 코드의 기본 흐름이 우 -> 좌, 아래 -> 위로 갈 수도 있지만 그렇지 않은 것은 언어를 짠 사람이 만든 규칙 때문임
* 이러한 a, b, c 언어의 유일한 예외는 = assignment
* a = 3; 은 실제로 우에서 좌로 할당됨
    * 3이 우 -> 좌로 들어옴
    * 수학자들이 초창기의 a, b, c 언어를 만들었기 때문
    * 이러한 관습이 이어져옴
        * e.g. plus(1, 2) 여도 되지만 연산자를 사용하는 이유는 수학자들이 만들었기 때문
    * 휴먼 에러는 우 -> 좌로의 할당, 연산자로 인해서 많이 발생됨
    * 복잡성을 떨어뜨리고자 한다면 이러한 휴먼 에러를 최대한 막는 것이 좋음

* 프로그램에서 외부의 입력을 받지 않으면 프로그램의 변화를 만들 수 없기 때문에 효용성이 떨어짐 -> 고정된 프로그램에 입력값의 변화, 즉 flow 제어를 하고자 하는 이유는 이 때문

* 노이만 머신의 flow에 관여하는 방법
    * 제어문 sync flow control statement
        * sync flow control: flow의 분기, flow 특정 구간의 반복, 특정 구간 점프
        * sub flow: sync flow controll의 방법으로 main flow에서 빠져나와 sub flow를 타고 다시 main flow로 가는 등의 처리
            * 함수, 클래스 콜로 처리
        * 문, 식을 사용해서 flow 제어를 조직화 -> flow control

* sub flow를 포함한 sync flow control은 프로그램이 실행되면 반드시 종료되게 됨
* es6 generator는 flow의 진행을 중단시키고, 다른 구간을 실행하다가 중단시켰던 지점에서 다시 실행시킬 수 있음
    * 하나의 flow가 다 도는 흐름을 루틴이라고 부름 
        * 전체 flow는 한번만 돎
        * 진입하면 끝까지 실행되고 빠져나가는 단위
    * sub flow처럼 여러번 돌 수 있는 flow는 서브루틴이라고 부름
    * 코루틴은 여러 번 진입하고 여러번 빠져나갈 수 있음
    * 현대화되어있는 랭귀지(java 9, es6 같은..)들은 전통적인 a, b, c 언어와 달리 흐름처럼 한번에 흐르는 루틴이 아닌 복잡한 루틴을 다루고 있음

* 제어문은 왜 for, while, do while, if, switch 등으로 중복된 같은 기능이 나누어져있을까
    * 코드로 복잡한 인간의 의도를 표현하기 위함
    * 코드의 의도는 제어문에 존재함 
        * 흔히 알려진 것처럼 변수 이름에 존재하지 않음

* if문 
    * 공백 문자(스페이스, 탭)는 몇 개를 넣어도 하나의 공백으로 보게 됨
        * js에서 엔터는 개행 기능이 있으므로 제외
    * 제어문은 자바스크립트 엔진에 주는 힌트이기 때문에 철저히 엔진이 무엇이 제어문인지 오해할 수 없게 정의되어있음
    * if 소문자 키워드 뒤에 공백 문자가 n개 0 이상 올 수 있고 괄호 사이에 식이 온 후 문이 올 수 있음 
    * e.g. if (ex) st
        * 단문의 자리에는 중문이 올 수 있으므로 if (ex) {st}도 가능
        * 자바스크립트에서의 괄호
            * 산술 연산식에서 우선 순위 연산자
            * 제어문의 형식 기호: 제어문에 들어가는 기호
            * 함수 호출식 연산자
        * 괄호 안의 식이 참이면 괄호 다음의 문이 실행됨 -> optional
    * e.g. if (ex) st else st
        * else 앞에는 개행, 공백 문자 올 수 있음
        * 괄호 안의 식 앞뒤에도 개행, 공백 문자 올 수 있음
        * 둘 중에 하나는 반드시 실행 -> mtory
    * e.g. if (true) 3; else 5
        * 식의 자리에 값식, 문의 자리에 값식으로 된 식문
        * if (true) { 3 } else { 5 } 중문도 가능

* 인간의 뇌는 위험요소를 인지했을 때 go, stop의 판단을 내리기 위해 최적화 되어있음 -> 양자택일 최적화
    * 인간은 경우의 수를 2진법의 연쇄로 판단하는 것이 더 쉬움 
    * if 만 쓰여있는 경우는 optional한 덜 중요한 경우, if else로 쓰인 경우는 필수적인 경우이므로 중요한 경우..라고 표현하는 것임을 인지해야함






